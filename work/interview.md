<!--
 * @Author: 肖玲11
 * @Date: 2024-10-11 15:37:24
 * @LastEditTime: 2025-03-03 11:14:47
 * @LastEditors: 肖玲
 * @Description:
 * @FilePath: /javascript_Handwritten_code/work/interview.md
 * 面试
-->

# 1、详细阐述 vue 和 react 这两个框架的核心差异

vue：易用性和直观性。通过双向数据绑定简化了状态管理
react：注重于组件化和状态管理的灵活性，通过单向数据流和 jsx 提供更细颗粒度的控制

## 基于什么标准选择这两个框架：

《1》评估项目需求：是否需要快速迭代。强大的社区支持。例如需要高度的组件复用和状态管理会选择 react，如果需要快速上手上手项目需求相对比较简单那么选择 vue 会更合适。
《2》团队成员的技术栈偏好和框自身的长期维护性和稳定性。

# 2、深入解释一下 vue 的路由底层实现机制

vue 的路由机制通过 vue-router 提供了高效的单页面应用路由管理方案、其底层主要依赖于浏览器的 hash 或 history API 来捕捉 URL 变化，通过路由表匹配组件，并结合路由守卫和动态加载技术优化用户体验。
需要从以下几方面剖析它的底层原理：
《1》路由模式（History 和 Hash 模式）
Hash 模式：
| 路由模式 | Hash 模式 | History 模式 | 
| :--- | :----: | ---: |
| 实现方式 | 利用 URL 中的 # （哈希）部分，window.location.hash 被用作路由标识。 | 依赖 HTML5 History API 中的 pushState 和 replaceState 方法。这些方法允许开发者手动修改浏览器的历史记录而不刷新页面，同时更新地址栏。 |
| 浏览器实现 | 哈希值的变化不会导致页面刷新，但可以触发 hashchange 事件。Vue 通过监听这个事件来响应 URL 变化，并更新页面内容。 | Vue 通过监听 popstate 事来捕捉浏览器历史状态的变化。 |
| 优点 | 兼容性好，因为哈希是浏览器原声支持的 | URL 没有 # ，看起来更干净，更像传统的多页面应用。 |
| 缺点 | URL 中会带有 # ，不太美观。 | 需要后台服务器支持，因为用户直接访问某个页面的时候，服务器必须返回对应的 HTML 文件。 |
| 事例 | http://example.com/#/home | http://example.com/home |

《2》路由匹配机制
Vue 的路由系统通过内部的路由表来匹配 URL 与相对应的组件。每个路由项由 path 和 component 定义：
· path：表示 URL 路径，可以包含动态参数（例如：/user/:id）
· component：对应的 Vue 组件
路由表的核心数据结构其实就是一个数组，每个元素就是一个路由配置对象。vue-router 通过递归遍历路由表来查找与当前 URL 匹配的路由。

```javascript
const routes = [
    { path: '/home', component: Home },
    { path: '/user/:id', component: User },
]
```

当 URL 发生变化时，vue-router 会根据路由表依次匹配每一项的 path，找出对应的组件并渲染。
动态参数匹配:
vue-router 使用类似于正则表达式的方式来匹配带参数的路由。例如，当 URL 为/user/123 时，它会匹配/user/:id，并将 id 的值作为参数传递给相应的组件。

《3》路由跳转与导航守卫
Vue 路由的跳转不仅仅是 URL 的变化，还包括导航的前置和后置处理，即所谓的导航守卫。
· 编程式导航：使用 router.push()或 router.replace()方法进行跳转
· 导航守卫：一系列的回调函数，允许开发者在路由跳转前后进行处理。主要分为以下几种类型：
！· 全局守卫：如 beforeEach、afterEach，对所有的路由都生效。
！· 路由独享守卫：在路由配置中的 beforeEnter 钩子。
！· 组件内守卫：在组件内部定义 beforeRouteEnter、beforeRouteUpdate 和 beforeRouteLeave。
这些守卫的执行流程是：全局守卫 -> 路由独享守卫 -> 组件前置守卫，跳转成功之后会触发全局后置守卫。

```javascript
router.beforeEach((to, from, next) => {
    //进行一些判断或异步操作
    next() //允许跳转
})
```

《4》动态路由和懒加载
· 动态路由：Vue 支持根据用户行为动态添加或删除路由。使用 router.addRoute()方法可以在运行时动态添加新路由，这在某些需要动态加载功能模块的场景中非常有用。

```javascript
router.addRoute({ path: '/new-route', component: 'NewComponent' })
```

· 懒加载：Vue 通过 webpack 的 code splitting 功能，将路由组件分割成单独的 JavaScript 文件，按需加载。这减少了初始加载的文件体积，加快页面的首次加载时间。

```javascript
const routes = [
    {
        path: '/about',
        component: () =>
            import(/*webpackChunkName:"about"*/ './component/About.vue'),
    },
]
```

《5》路由组件的渲染原理
vue-router 是通过<router-view>组件来动态渲染与当前路由匹配的组件。每当路由改变时，<router-view>组件会根据路由表重新渲染相应的组件。
· 工作原理：Vue 在内部维护一个当前路由对象 currentRoute，并通过 watch 机制监听这个对象的变化。当 URL 发生变化时，currentRoute 被更新，<router-view>重新渲染。
· 嵌套路由：当有嵌套的路由配置时，<router-view>可以嵌套使用，每一层级的 router-view 渲染其对应层级的子组件。

```html
<!-- App.vue -->
<template>
    <div>
        <router-view></router-view>
    </div>
</template>
```

# 事件循环：浏览器的核心原理

## 浏览器的进程模型

### 1、进程

程序运行需要有它自己专属的内存空间，可以把这块内存空间简单理解成进程。每个应用至少要有一个进程，进程之间相互独立，即使要通信，也需要双方同意。
![alt text](image-1.png)

### 2、线程

有了进程之后，就可以运行程序的代码了。运行代码的【人】称之为【线程】。
一个进程至少有一个线程，所以进程开启后会自动创建一盒线程来运行代码，该线程称为主线程。
如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。
![alt text](image-2.png)

## 浏览器有哪些进程和线程

浏览器是一个多进程多线程的应用程序。内部工作及其复杂。
为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。
_可以在浏览器的任务管理器中查看当前的所有进程。_
![alt text](image-3.png)
其中最主要的进程有：
1、浏览器进程
主要负责界面展示、用户交互和子进程管理等。浏览器进程内部会启用多个线程处理不同的任务。

2、网络进程
负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。

3、渲染进程
渲染进程启动后，会开启一个渲染主线程（事件循环发生），主线程负责执行 HTML、CSS、JS 的代码。
默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同标签页之间不相互影响。 _将来该默认模式可能会有所改变（标签页太多，进程太多太耗内存空间了：内存杀手）一个站点一个进程（减少进程数量），有兴趣可以参见 [chrome 官方说明文档](https://developer.chrome.com/docs?hl=zh-cn)_。

## 渲染主线程是如何开始工作

渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：

-   解析 HTML
-   解析 CSS
-   计算样式
-   布局
-   处理图层
-   每秒把页面画 60 次
-   执行全局 JS 代码
-   执行事件处理函数
-   执行计时器的回调函数
-   ......

_为什么渲染进程不适用于多个线程来处理这些事情(工作两三年后思考)？要处理这么多的任务，主线程遇到难题：如何调度任务？_
比如：

-   我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？
-   我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调函数吗？
-   浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个函数？
-   ......

渲染主线程绝妙主意处理这个问题：排队
![alt text](image-4.png)

1、在最开始的时候，渲染主线程会进入一个无限循环
2、每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环，如果没有，则进入休眠状态。
3、其他所有线程（包括其他进程的线程）可以随时向消息队列中添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。
这样一来，就可以让每个任务有条不紊的、持续的进行下去了。
**整个过程，被称之为事件循环（消息循环）**

## 若干解释

### 异步

代码在执行过程中，会遇到一些无法立即处理的任务，比如：

-   计时完成后需要执行的任务 -- setTimeout、setInterval
-   网络通信完成后需要执行的任务 -- XHR、Fetch
-   用户操作后需要执行的任务 -- addEventListener

如果让渲染主线程等待这些任务的时机到达，就会导致主线程长期处于【阻塞】的状态，从而导致浏览器【卡死】
同步：
![alt text](image-5.png)
_**渲染主线程承担者极其重要的工作，无论何时都不能阻塞，浏览器选择用异步解决这个问题**_
异步：
![alt text](image-6.png)
_使用异步的方式，渲染主线程永不阻塞_

```html
面试题：如何理解JS的异步
参考回答：JS是一门单线程语言，这是因为它运行在浏览器的渲染主线程中。
渲染主线程只有一个。然而渲染主线程却又承担着诸多工作，例如渲染页面、执行JS代码。
如果使用同步的方式，就极有可能导致主线程阻塞，从而导致消息队列中很多其它任务无法得到执行。
这样一来，一方面会导致繁忙的主线程白白耗费时间，另一方面导致页面无法及时更新，给用户造成卡死现象。
所以浏览器采用异步的的方式来避免。具体做法是当某些任务发生的时候，比如计时器，网络，事件监听，主线程将这些任务交给其它线程去处理，
自身立即结束任务的执行，转而执行后续代码。当其它线程完成时，再将事先传递的回调函数包装成任务（浏览的任务是一个结构体，即一个对象）
加入到消息队列的末尾排队，等待主线程调度执行。
在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
```

### JS 为什么会阻碍渲染

看一段代码

```html
<html>
    <body>
        <h1>Mr Yuan is awaesome!</h1>
        <button>change</button>
        <script>
            var h1 = document.querySelector('h1')
            var btn = document.querySelector('button')
            // 死循环指定的时间
            function delay(duration) {
                var start = Date.now()
                while (Date.now() - start < duration) {}
            }

            btn.onclick = function () {
                h1.textContent = '袁老师很帅！'
                delay(3000)
            }
        </script>
    </body>
</html>
```

总结：渲染页面和执行 JS 代码都在渲染主线程上。

### 任务优先级

任务没有优先级，在消息队列中先进先出
但**消息队列是有优先级的**
根据 W3 的最新解释：

-   每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同任务类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
-   浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。
    https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint

```html
随着浏览器的复杂度急剧上升，W3C不再使用宏队列的说法
```

在目前的 chrome 的实现中，至少包含了下面的队列：

-   延时队列：用于存放计时器到达后的回调任务，优先级【中】
-   交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】
-   微队列：用户存放需要最快执行的任务，优先级【最高】
